### 1. 下面有关c++内存分配堆栈说法错误的是

**🔍 选项**

```
A.对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制

B.对于栈来讲，生长方向是向下的，也就是向着内存地址减小的方向；对于堆来讲，它的生长方向是向上的，是向着内存地址增加的方向增长

C.对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题

D.一般来讲在 32 位系统下，堆内存可以达到4G的空间，但是对于栈来讲，一般都是有一定的空间大小的
```

**✨ 解析**

```
答案：D

A.栈区主要存在局部变量和函数参数，其空间的管理由编译器自动完成，无需手动控制，堆区是自己申请的空间，在不需要时需要手动释放

B.栈区先定义的变量放到栈底，地址高，后定义的变量放到栈顶，地址低，因此是向下生长的，堆区则相反

C.频繁的申请空间和释放空间，容易造成内存碎片，甚至内存泄漏，栈区由于是自动管理，不存在此问题

D.32位系统下，最大的访问内存空间为4G,所以不可能把所有的内存空间当做堆内存使用，故错误，需要使用64位系统才能满足要求
```



### 2. C++中关于堆和栈的说法，哪个是错误的

**🔍 选项**

```
A.堆的大小仅受操作系统的限制，栈的大小一般较小

B.在堆上频繁的调用new/delete容易产生内存碎片，栈没有这个问题

C.堆和栈都可以静态分配

D.堆和栈都可以动态分配
```

**✨ 解析**

```
答案：C

A.堆大小受限于操作系统，而栈空间一般有系统直接分配

B.频繁的申请空间和释放空间，容易造成内存碎片，甚至内存泄漏，栈区由于是自动管理，不存在此问题

C.堆无法静态分配，只能动态分配

D.栈可以通过函数_alloca进行动态分配，不过注意，所分配空间不能通过free或delete进行释放
```



### 3. C++语言中，类ClassA的构造函数和析构函数的执行次数分别为

**📃 代码**

```cpp
ClassA *pclassa=new ClassA[5];

delete pclassa;
```

**🔍 选项**

```
A.5,1

B.1,1

C.5,5

D.程序可能崩溃
```

**✨ 解析**

```
答案：D

A.申请对象数组，会调用构造函数5次，delete由于没有使用[]，此时只会调用一次析构函数，但往往会引发程序崩溃

B.构造函数会调用5次

C.析构函数此时只会调用1次，要想完整释放数组空间，需要使用[]

D.正确
```



### 4. 函数参数使用的空间是在（）中申请的，malloc或new是在（）中申请空间的

**🔍 选项**

```
A.堆，栈

B.栈，堆

C.栈， 栈

D.堆，堆
```

**✨ 解析**

```
答案：B

A.参数在栈空间存放，malloc或new申请的空间为堆区

B.正确

C.参数在栈空间存放，malloc或new申请的空间为堆区

D.参数在栈空间存放，malloc或new申请的空间为堆区
```



### 5. 下面有关malloc和new，说法错误的是

**🔍 选项**

```
A.new 是创建一个对象(先分配空间，再调构造函数初始化)， malloc分配的是一块内存

B.new 初始化对象，调用对象的构造函数，对应的delete调用相应的析构函数，malloc仅仅分配内存，free仅仅回收内存

C.new和malloc都是保留字，不需要头文件支持

D.new和malloc都可用于申请动态内存，new是一个操作符，malloc是一个函数
```

**✨ 解析**

```
答案：C

A.new会申请空间，同时调用构造函数初始化对象，malloc只做一件事就是申请空间

B.new/delete与malloc/free最大区别就在于是否会调用构造函数与析构函数

C.需要头文件malloc.h,只是平时这个头文件已经被其他头文件所包含了，用的时候很少单独引入，故错误

D.new是操作符，malloc是函数
```



### 6. 设已经有A,B,C,D，4个类的定义，程序中A,B,C,D析构函数调用顺序为

**📃 代码**

```cpp
C c;

void main()
{
  A* pa = new A();
  B b;
  static D d;
  delete pa;
}
```

**🔍 选项**

```
A.A B C D

B.A B D C

C.A C D B

D.A C B D
```

**✨ 解析**

```
答案：B

首先手动释放pa， 所以会先调用A的析构函数。

其次C B D的构造顺序为 C D B，因为先构造全局对象，在构造局部静态对象，最后才构造普通对象，然而析构对象的顺序是完全按照构造的相反顺序进行的，所以答案为 B
```



### 7. 使用 `char* p = new char[100]` 申请一段内存，然后使用delete p释放，有什么问题

**🔍 选项**

```
A.会有内存泄露

B.不会有内存泄露，但不建议用

C.编译就会报错，必须使用delete []p

D.编译没问题，运行会直接崩溃
```

**✨ 解析**

```
答案：B

A.对于内置类型，此时delete就相当于free，因此不会造成内存泄漏

B.正确

C.编译不会报错，建议针对数组释放使用delete[],如果是自定义类型，不使用方括号就会运行时错误

D.对于内置类型，程序不会崩溃，但不建议这样使用
```



### 8. 以下代码中，A 的构造函数和析构函数分别执行了几次

**📃 代码**

```cpp
A*pa=new A[10];
delete []pa;
```

**🔍 选项**

```
A.1、1

B.10、10

C.1、10

D.10、1
```

**✨ 解析**

```
答案：B

A.申请数组空间，构造函数调用的次数就是数组的大小

B.正确

C.申请数组空间，构造函数调用的次数就是数组的大小

D.如果释放数组空间，delete使用了[]，则会对应的调用数组大小次数的析构函数
```



### 9. 变量所在哪个内存区域以及变量所占空间大小是多少

**📃 代码**

```cpp
int globalVar = 1;

static int staticGlobalVar = 1;

void Test()

{

static int staticVar = 1;

int localVar = 1;

int num1[10] = {1, 2, 3, 4};

char char2[] = "abcd";

char* pChar3 = "abcd";

int* ptr1 = (int*)malloc(sizeof (int)*4);

int* ptr2 = (int*)calloc(4, sizeof(int));

int* ptr3 = (int*)realloc(ptr2, sizeof(int)*4);

free (ptr1);

free (ptr3);

}
```

**🔍 选择题**

```
1. 选择题：

  选项: A.栈 B.堆 C.数据段(静态区) D.代码段(常量区)

  globalVar在哪里？____  staticGlobalVar在哪里？____

  staticVar在哪里？____  localVar在哪里？____

  num1 在哪里？____

  

  char2在哪里？____   *char2在哪里？___

  pChar3在哪里？____   *pChar3在哪里？____

  ptr1在哪里？____    *ptr1在哪里？____

```

**🔍 填空题**

```
2. 填空题：

  sizeof(num1) = ____;  

  sizeof(char2) = ____;   strlen(char2) = ____;

  sizeof(pChar3) = ____;   strlen(pChar3) = ____;

  sizeof(ptr1) = ____;
```

**✨ 解析一**

```
globalVar在哪里？C  staticGlobalVar在哪里？C
staticVar在哪里？C  localVar在哪里？A
num1 在哪里？A
char2在哪里？A  *char2在哪里？D
pChar3在哪里？A  *pChar3在哪里？D
ptr1在哪里？A  *ptr1在哪里？B

globalVar是全局变量在数据段
staticGlobalVar是静态全局变量在静态区
staticVar是静态局部变量在静态区
localVar是局部变量在栈区
num1是局部变量在栈区
char2局部变量在栈区
char2是一个数组，把后面常量串拷贝过来到数组中，数组在栈上，所以*char2在栈上
pChar3局部变量在栈区 *pChar3得到的是字符串常量字符在代码段
ptr1局部变量在栈区 *ptr1得到的是动态申请空间的数据在堆区
```

**✨ 解析二**

```
sizeof(num1) = 40;//数组大小,10个整形数据一共40字节

sizeof(char2) = 5;//包括\0的空间

strlen(char2) = 4;//不包括\0的长度

sizeof(pChar3) = 4;//pChar3为指针

strlen(pChar3) = 4;//字符串“abcd”的长度，不包括\0的长度

sizeof(ptr1) = 4;//ptr1是指针，在32位操作系统下为四字节
```



