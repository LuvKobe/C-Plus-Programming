### 1. 已知表达式 `++a` 中的"++"是作为成员函数重载的运算符，则与`++a`等效的运算符函数调用形式为

**🔍 选项**

```
A. a.operator++()

B. a.operator++(0)

C. a.operator++(int)

D. operator++(a,0)
```

**✨ 解析**

```
答案：A

A.正确

B.operator++()传递了整形参数，故为后置++,错误

C.调用函数传递类型，导致语法错误

D.参数过多，语法错误
```



### 2. 在重载一个运算符为成员函数时，其参数表中没有任何参数，这说明该运算符是

**🔍 选项**

```
A.无操作数的运算符

B.二元运算符

C.前缀一元运算符

D.后缀一元运算符
```

**✨ 解析**

```
答案：C

A.重载为成员函数时，其函数的参数个数与真实的函数参数个数会减少1个，减少的则 通过this指针进行传递，所以无参 则说明有一个参数，故错误

B.无参成员函数相当于有一个参数的全局函数,不能是二元运算符

C.正确

D.区分前缀后缀时，后缀运算需要加一个int参数
```



### 3. 哪个操作符不能被重载

**🔍 选项**

```
A. *

B. ()

C. . (点)

D. []

E. ->
```

**✨ 解析**

```
答案：C

A.可以，例如重载对象取值，典型有以后学到的智能指针

B.可以，例如以后学到的仿函数就是通过重载()实现的

C.不能，不能被重载的运算符只有5个， 点号. 三目运算?: 作用域访问符:: 运算符sizeof 以及.*

D.可以，例如重载对象的指向，典型有以后学到的智能指针
```



### 4. 若要对data类中重载的加法运算符成员函数进行声明，下列选项中正确的是

**🔍 选项**

```
A.Data operator+(Data);

B.Data operator(Data);

C.operator+(Data,Data);

D.Data+(Data);
```

**✨ 解析**

```
答案：A

A.正确

B.语法错误，缺少运算符+

C.成员函数参数过多

D.没有运算符重载关键字operator
```



### 5. 假设 AA 是一个类， `AA* abc() const` 是该类的一个成员函数的原型。若该函数返回 this 值，当用 `x.abc ()` 调用该成员函数后， x 的值是

**🔍 选项**

```
A.可能被改变

B.已经被改变

C.受到函数调用的影响

D.不变
```

**✨ 解析**

```
答案：D

A.此成员函数被定义为const常方法，代表在函数内部不能修改任何当前对象的数据成员，因此x不可能改变

B.错误，不能被改变

C.x的值在函数内部不受任何影响

D.正确
```



### 6. 下列关于赋值运算符 `=` 重载的叙述中，正确的是

**🔍 选项**

```
A.赋值运算符只能作为类的成员函数重载

B.默认的赋值运算符实现了“深层复制”功能

C.重载的赋值运算符函数有两个本类对象作为形参

D.如果己经定义了复制拷贝构造函数，就不能重载赋值运算符
```

**✨ 解析**

```
答案：A

A.赋值运算符在类中不显式实现时，编译器会生成一份默认的，此时用户在类外再将赋值运算符重载为全局的，就和编译器生成的默认赋值运算符冲突了，故赋值运算符只能重载成成员函数

B.默认的赋值运算符是按成员成员，属于浅赋值

C.参数只有一个，另一个通过this指针传递

D.两个函数的调用场景不同，相互没有影响
```





























