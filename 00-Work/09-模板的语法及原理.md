### 1. 下面有关C++中为什么用模板类的原因，描述错误的是

**🔍 选项**

```
A.可用来创建动态增长和减小的数据结构

B.它是类型无关的，因此具有很高的可复用性

C.它运行时检查数据类型，保证了类型安全

D.它是平台无关的，可移植性
```

**✨ 解析**

```
答案：C

A.模板可以具有非类型参数，用于指定大小，可以根据指定的大小创建动态结构

B.模板最重要的一点就是类型无关，提高了代码复用性

C.模板运行时不检查数据类型，也不保证类型安全，相当于类型的宏替换，故错误

D.只要支持模板语法，模板的代码就是可移植的
```



### 2. 在下列对fun的调用中，错误的是

**📃 代码**

```cpp
template<class T>
T fun(T x, T y) 
{
	return x * x + y * y;
}
```

**🔍 选项**

```
A.fun(1, 2)

B.fun(1.0, 2)

C.fun(2.0, 1.0)

D.fun<float>(1, 2.0)
```

**✨ 解析**

```
答案：B

这里T要求类型一致

A.类型一致，为int型

B.类型不一致，错

C.类型一致，为folat型

D.用<float>进行声明，后面的实参会强制类型转换为float，所以也是类型一致的。
```



### 3. 下列关于模板的说法正确的是

**🔍 选项**

```
A.模板的实参在任何时候都可以省略

B.类模板与模板类所指的是同一概念

C.类模板的参数必须是虚拟类型的

D.类模板中的成员函数全是模板函数
```

**✨ 解析**

```
答案：D

A.不一定，参数类型不同时有时需要显示指定类型参数

B.类模板是一个类家族，模板类是通过类模板实例化的具体类

C.C++中类模板的声明格式为template＜模板形参表声明＞＜类声明＞，并且类模板的成员函数都是模板函数

D.正确，定义时都必须通过完整的模板语法进行定义
```



### 4. 下列的模板声明中，其中几个是正确的

**📃 代码**

```cpp
1)template 

2)template<T1,T2>

3)template<class T1,T2>

4)template<class T1,class T2>

5)template<typename T1,T2>

6)template<typename T1,typename T2>

7)template<class T1,typename T2>

8)<typename T1,class T2>
```

**🔍 选项**

```
A.2

B.3

C.4

D.5
```

**✨ 解析**

```
答案：A

1) error

2) error

3) error

4) true

5) error

6) true

7) error

8) error
```



### 5. 下列描述错误的是

**🔍 选项**

```
A.编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础

B.函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具

C.模板分为函数模板和类模板

D.模板类跟普通类以一样的，编译器对它的处理时一样的
```

**✨ 解析**

```
答案：D

A.模板是代码复用的重要手段

B.函数模板不是一个具体函数，而是一个函数家族

C.目前涉及到的模板就两类，函数模板与类模板

D.模板类是一个家族，编译器的处理会分别进行两次编译，其处理过程跟普通类不一样
```













