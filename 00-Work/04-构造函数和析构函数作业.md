### 1. 下列关于构造函数的描述正确的是

**🔍 选项**

```
A.构造函数可以声明返回类型

B.构造函数不可以用private修饰

C.构造函数必须与类名相同

D.构造函数不能带参数
```

**✨ 解析**

```
答案：C

解析：

A.构造函数不能有返回值，包括void类型也不行

B.构造函数可以是私有的，只是这样之后就不能直接实例化对象

C.这是必须的

D.构造函数不光可以带参数，还可以有多个构造函数构成重载
```



### 2. 假定MyClass为一个类，则该类的拷贝构造函数的声明语句是

**🔍 选项**

```cpp
A.MyClass(MyClass x)
    
B.MyClass &(MyClass x)
    
C.MyClass(MyClass &x)
    
D.MyClass(MyClass *x)
```

**✨ 解析**

```
答案：C

解析：

A.参数必须是引用，否则造成无限递归

B.语法错误

C.正确

D.这种写法只是普通的构造函数，不能成为拷贝构造函数
```



### 3. 在函数F中，本地变量`a`和`b`的构造函数(constructor)和析构函数(destructor)的调用顺序是

**📃 代码**

```cpp
Class A;
Class B;

void F() {
	A a;
  	B b;
}
```

**🔍 选项**

```
A.b构造 a构造 a析构 b析构

B.a构造 a析构 b构造 b析构

C.b构造 a构造 b析构 a析构

D.a构造 b构造 b析构 a析构
```

**✨ 解析**

```
答案：D

解析：

A.构造顺序是按照语句的顺序进行构造，析构是按照构造的相反顺序进行析构，因此先构造b错误

B.a析构的时机不对，对象析构要在生存作用域结束的时候才进行析构，因此先析构a错误

C.b的构造时机错误，先构造a

D.正确，构造顺序是按照语句的顺序进行构造，析构是按照构造的相反顺序进行析构
```



### 4. 以下代码共调用多少次拷贝构造函数

**📃 代码**

```cpp
Widget f(Widget u)
{  
  	Widget v(u);
  	Widget w=v;
  	return w;
}

int main() 
{
  	Widget x;
  	Widget y=f(f(x));
}
```

**🔍 选项**

```
A.1

B.3

C.5

D.7
```

**✨ 解析**

```
答案：D

解析：

A.调用拷贝构造函数的时机，从代码上看会有三种情形，1.对象初始化对象 2.函数参数以对象传递 3.函数的返回值以对象返回，因此乍眼一看，超过1次，A错误

B.整个程序分别在,x初始化u、u初始化v、v初始化w、w返回时，注意w返回时初始u不在调用拷贝构造函数，第二次调用 f()函数时，相当于u的结合会少调用一次，其他不变，所以总体次数为4+3=7次

C.错误

D.正确
```



### 5. 设已经有A、B、C、D，4个类的定义，程序中A,B,C,D析构函数调用顺序为

**📃 代码**

```cpp
C c;

int main()
{
	A a;
	B b;
	static D d;
  	return 0；
}
```

**🔍 选项**

```
A. D B A C

B. B A D C

C. C D B A

D. A B D C
```

**✨ 解析**

```
答案：B

解析：

分析:1、类的析构函数调用一般按照构造函数调用的相反顺序进行调用，但是要注意static对象的存在， 因为static改变了对象的生存作用域，需要等待程序结束时才会析构释放对象

2、全局对象先于局部对象进行构造

3、局部对象按照出现的顺序进行构造，无论是否为static

4、所以构造的顺序为 c a b d

5、析构的顺序按照构造的相反顺序析构，只需注意static改变对象的生存作用域之后，会放在局部 对象之后进行析构

6、因此析构顺序为B A D C
```



### 6. 拷贝构造函数的特点是

**🔍 选项**

```
A.该函数名同类名，也是一种构造函数，该函数返回自身引用

B.该函数只有一个参数，是对某个对象的引用

C.每个类都必须有一个拷贝初始化构造函数，如果类中没有说明拷贝构造函数，则编译器系统会自动生成一个缺省拷贝构造函数，作为该类的保护成员

D.拷贝初始化构造函数的作用是将一个已知对象的数据成员值拷贝给正在创建的另一个同类的对象
```

**✨ 解析**

```
答案：D

解析：

A.拷贝构造函数也是一构造函数，因此不能有返回值

B.该函数参数是自身类型的对象的引用

C.自动生成的缺省拷贝构造函数，作为该类的公有成员，否则无法进行默认的拷贝构造

D.用对象初始化对象这是拷贝构造函数的使命，故正确
```









